
.. _prediction:

Предсказатель
=============

В тех случаях, когда слово не получается найти простым поиском
по словарю (с :ref:`учетом <umlauts>` буквы "ё"), в дело вступает предсказатель.

Предсказатель основан на идее о том, что если слова в русском языке
оканчиваются одинаково, то и форму они имеют, скорее всего, одинаковую.

.. note::

    Алгоритм предсказания в основе своей похож на тот, что описан на
    `aot.ru <http://aot.ru>`_, и на тот, что применяется в pymorphy1_,
    но отличается в деталях и содержит дополнительные эвристики.

.. _pymorphy1: http://pymorphy.readthedocs.org/en/latest/algo.html#prediction-algo


Для предсказателя реализованы 2 алгоритма предсказания, которые
работают совместно.

Первый подход: отсечение префиксов
----------------------------------

Если 2 слова отличаются только тем, что к одному из них что-то приписано
спереди, то, скорее всего, и склоняться они будут одинаково.

Это особенно справедливо в тех случаях, когда это "что-то" - один из
известных словообразовательных префиксов (например, "КОШКА" - "ПСЕВДОКОШКА").

В pymorphy2 хранится небольшой список таких префиксов; если слово
начинается с одного из таких префиксов, то префикс отсекается, а остаток
передается на разбор.

Если слово не начинается с такого префикса, то пробуем считать
сначала одну первую букву слова префиксом, потом 2 первых буквы и т.д.
А то, что осталось, передаем морфологическому анализатору. Ну и делаем
это только для не очень длинных префиксов и не очень коротких остатков.

Второй подход: предсказание по концу слова
------------------------------------------

В подходе с отсечением префиксов есть одно принципиальное ограничение:
морфологический анализатор должен уметь разбирать правую часть слова.
Разбор многих слов нельзя предсказать таким образом. Например, хотелось бы,
чтоб если в словаре было слово "КОШКА", но не было "МОШКА" и "ОШКА",
на основе словарного слова "КОШКА" анализатор смог бы предположить, как
склоняется "МОШКА".

Для того, чтоб предсказывать формы слов по тому, как слова заканчиваются,
при конвертации словарей строится DAWG со всеми возможными окончаниями
слов (от однобуквенных до пятибуквенных сейчас); каждому окончанию
сопоставляется массив с возможными вариантами разбора слов с такими
окончаниями.

.. note::

    XXX: можно ли не хранить четырехбуквенное окончание, если уже
    хранится пятибуквенное? Приведет ли это к какому-то выигрышу
    по оперативной памяти?

Схема хранения тут точно такая-же, как и в основном словаре
(см. раздел :ref:`Упаковка слов <word-packing>`), только вместо слова
хранятся окончания слов, и кроме номера парадигмы и индекса формы в
парадигме добавляется еще информация о "продуктивности" данного
правила - количество слов в словаре, которые имеют данное окончание
и разбираются данным образом.

    <КОНЕЦ СЛОВА> <разделитель> <ПРОДУКТИВНОСТЬ> <НОМЕР ПАРАДИГМЫ> <НОМЕР ФОРМЫ В ПАРАДИГМЕ>

Если хранить все возможные варианты разбора, то получится заведомо много
лишних (очень маловероятных) правил. Поэтому скрипт компиляции
словаря умеет отсекать правила по нескольким критериям:

- парадигма должна быть "продуктивной": в словаре должно иметься хотя-бы
  ``min_paradigm_popularity`` лемм, разбираемых по этой парадигме;
- "окончания" должны быть распространенными: в словаре должно иметься хотя
  бы ``min_ending_freq`` слов, которые заканчиваются так;
- вариант разбора должен быть популярным: для данного окончания для каждой
  части речи оставляем только ``max_forms_per_class`` наиболее популярных
  вариантов разбора;

По умолчанию ``min_paradigm_popularity == 3``,
``min_ending_freq = 2``, ``max_forms_per_class = 1``.

Ограничение на части речи
-------------------------

В русском языке не все части речи продуктивные: например, нельзя приписать
что-то к предлогу, чтоб получить другой предлог; все предлоги есть в словаре,
и предсказывать незнакомые слова как предлоги неправильно. В предсказателе
поэтому такие варианты предсказания отбрасываются.

Слова, записанные через дефис
-----------------------------

.. warning::

    Разбор слов, записанных через дефис, еще не реализован.


Сортировка результатов разбора
------------------------------

При предсказании по концу слова результаты сортируются по "продуктивности"
вариантов разбора: наиболее продуктивные варианты будут первыми.

Другими словами, варианты разбора (= номера парадигм) упорядочены
по частоте, с которой эти номера парадигм соответствуют данному
окончанию для данной части речи - без учета частотности по корпусу.

Экспериментального доказательства правильности этого подхода нет никакой,
но "интуиция" тут такая:

1) нам не важно, какие слова в корпусе встречаются часто, т.к. предсказатель
   работает для редких слов, и редкие слова он должен предсказывать
   как редкие, а не как распространенные;
2) для "длинного хвоста" частотности в корпусе конкретные цифры имеют
   не очень много значения, т.к. флуктуации очень большие,
   "эффект хоббита" и т.д.
3) С другой стороны, важно, какие парадигмы в русском
   языке более продуктивные, какие порождают больше слов.

Поэтому используется частотность по парадигмам, полученная
исключительно из словаря.

.. note::

    В настоящий момент результаты сортируются только при предсказании
    по концу слова. Разборы для словарных слов и разборы, предсказанные
    путем отсечения префикса, специальным образом сейчас не сортируются.


Оценки для вариантов разбора
----------------------------

.. warning::

    Это очень экспериментальная возможность.

pymorphy2 приписывает каждому варианту разбора число (0.0 < x <= 1.0);
это число может служить оценкой того, насколько анализатор уверен в данном
варианте разбора.

Например, оценка 1.0 означает, что слово найдено в словаре,
а оценка 0.001 будет свидетельствовать о том, что это редкий вариант
разбора, предложенный предсказателем.

.. warning::

    Оценки нельзя рассматривать как значения вероятностей
    правильности разбора. Более того, никаких экспериментальных
    доказательств связи вероятности правильности разбора с оценкой
    предсказателя у меня тоже нет; "коэффициенты", на основе которых
    вычисляются оценки, выбраны вручную достаточно произвольно.


.. _OpenCorpora: http://opencorpora.org
